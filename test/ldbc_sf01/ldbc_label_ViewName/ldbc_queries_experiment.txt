MATCH p1=(p:Person)-[r1:KNOWS]-(friend:Person),p2 = (friend)<-[r2:HAS_CREATOR]-(message:Message) WHERE ID(p) = 15151 AND message.creationDate <= 1322000000000 WITH message,p2,r2 ORDER BY message.creationDate DESC, toInteger(ID(message)) ASC LIMIT 20  WITH collect(id(r2)) AS paths MERGE (v:View {ViewName :'V_IC2'}) SET v.PATHS = paths RETURN paths
MATCH (v:View) WHERE v.ViewName = "V_IC2" WITH v.PATHS AS allPaths UNWIND allPaths AS idR1 MATCH p=(p1:Person)-[r1:HAS_CREATOR]-(message:Message) WHERE id(r1) = idR1 RETURN p1,message 
MATCH p1=(person:Person)-[:KNOWS]-(friend:Person)<-[:HAS_CREATOR]-(post:Post),p2=(post)-[r2:HAS_TAG]->(tag) WHERE ID(person) =15151  WITH collect(id(r2)) AS paths MERGE (v:View {ViewName :'V_IC4'}) SET v.PATHS = paths RETURN paths
MATCH (v:View) WHERE v.ViewName = "V_IC2" WITH v.PATHS AS allPaths UNWIND allPaths AS idR1 MATCH p=(post:Post)-[r1:HAS_TAG]->(tag:Tag) WHERE id(r1) = idR1 WITH tag, CASE WHEN 1345000000000 <= post.creationDate < 1348000000000 THEN 1 ELSE 0 END AS valid, CASE WHEN post.creationDate <1345000000000 THEN 1 ELSE 0 END AS inValid WITH tag, SUM(valid) AS postCount, SUM(inValid) AS inValidPostCount WHERE postCount>0 AND inValidPostCount=0 RETURN tag ORDER BY postCount DESC LIMIT 10
MATCH (person:Person)-[:KNOWS*1..2]-(friend) WHERE ID(person) = 15151 AND NOT person=friend SET friend.ViewName = CASE WHEN friend.ViewName IS NOT NULL THEN friend.ViewName + ",V_IC5" ELSE ",V_IC5" END RETURN friend
CREATE TEXT INDEX v1 FOR (n:Person) on n.ViewName
MATCH (friend:Person)<-[membership:HAS_MEMBER]-(forum) WHERE friend.ViewName CONTAINS "V_IC5" AND membership.joinDate > 1322000000000 WITH forum, COLLECT(friend) AS friends OPTIONAL MATCH (friend)<-[:HAS_CREATOR]-(post)<-[:CONTAINER_OF]-(forum) WHERE friend IN friends WITH forum, COUNT(post) AS postCount RETURN forum.title AS forumName, postCount ORDER BY postCount DESC, ID(forum) ASC LIMIT 20
MATCH (knownTag:Tag) WHERE knownTag.name="Muammar_Gaddafi" WITH knownTag MATCH (person:Person)-[:KNOWS*1..2]-(friend) WHERE ID(person)= 15151 AND NOT person=friend WITH COLLECT(DISTINCT(friend)) + COLLECT(DISTINCT(knownTag)) AS allnodes UNWIND allnodes AS eachNode SET eachNode.ViewName = CASE WHEN eachNode.ViewName IS NOT NULL THEN eachNode.ViewName + ",V_IC6" ELSE ",V_IC6" END RETURN eachNode
CREATE TEXT INDEX v1 FOR (n:Person) on n.ViewName
CREATE TEXT INDEX v2 FOR (n:Tag) on n.ViewName
MATCH (f:Person)<-[:HAS_CREATOR]-(post:Post), (post)-[:HAS_TAG]->(t:Tag), (post)-[:HAS_TAG]->(tag:Tag) WHERE f.ViewName CONTAINS "V_IC6" AND  t.ViewName CONTAINS "V_IC6" AND NOT t = tag WITH tag.name as tagName, COUNT(post) as postCount RETURN tagName, postCount ORDER BY postCount DESC, tagName ASC LIMIT 10
MATCH p=(start:Person)<-[:HAS_CREATOR]-(m:Message)<-[:REPLY_OF]-(comment:Comment), p2 = (comment)-[r2:HAS_CREATOR]->(person:Person) WHERE ID(start) = 15035 WITH collect(id(r2)) AS paths MERGE (v:View {ViewName :'V_IC8'}) SET v.PATHS = paths RETURN paths
MATCH (v:View) WHERE v.ViewName = "V_IC8" WITH v.PATHS AS allPaths UNWIND allPaths AS idR1 MATCH p=(comment:Comment)-[r1:HAS_CREATOR]->(person:Person) WHERE id(r1)=idR1 RETURN ID(person) AS personId, person.firstName AS personFirstName, person.lastName AS personLastName, comment.creationDate AS commentCreationDate, ID(comment) AS commentId, comment.content AS commentContent ORDER BY commentCreationDate DESC, commentId ASC LIMIT 20
MATCH (tag:Tag)-[:HAS_TYPE|IS_SUBCLASS_OF*0..]->(baseTagClass:TagClass) WHERE tag.name = "OfficeHolder" OR baseTagClass.name = "OfficeHolder" WITH COLLECT(ID(tag)) as tags MATCH p1=(p:Person)-[r1:KNOWS]-(friend:Person)<-[r2:HAS_CREATOR]-(comment:Comment)-[r3:REPLY_OF]->(post:Post)-[r4:HAS_TAG]->(tag:Tag) WHERE ID(p) = 15151 AND ID(tag) IN tags WITH collect(id(r1) + '-' + id(r2)+ '-' + id(r3)+'-' + id(r4)) AS paths MERGE (v:View {ViewName:'V_IC12'}) SET v.PATHS = paths RETURN paths
MATCH (v:View) WHERE v.ViewName = "V_IC12" UNWIND v.PATHS AS path WITH SPLIT(path, '-') AS idPair, v WITH TOINTEGER(idPair[0]) AS idR1, TOINTEGER(idPair[1]) AS idR2, TOINTEGER(idPair[2]) AS idR3,TOINTEGER(idPair[3]) AS idR4 MATCH p=(person)-[r1:KNOWS]-(friend)<-[r2:HAS_CREATOR]-(comment)-[r3:REPLY_OF]->(post)-[r4:HAS_TAG]->(tag) WHERE id(r1)=idR1 AND  id(r2)=idR2 AND  id(r3)=idR3 AND  id(r4)=idR4 RETURN ID(friend) AS personId, friend.firstName AS personFirstName, friend.lastName AS personLastName, COLLECT(tag.name) AS tagNames, COUNT(comment) AS replyCount ORDER BY replyCount DESC, toInteger(personId) ASC LIMIT 20
MATCH (p:Person)<-[:HAS_CREATOR]-(message) WHERE ID(p) = 4102 WITH message ORDER BY message.creationDate DESC, ID(message) ASC LIMIT 10 WITH DISTINCT(message) SET message.ViewName = CASE WHEN message.ViewName IS NOT NULL THEN message.ViewName + ",V_IS2" ELSE ",V_IS2" END RETURN message
CREATE TEXT INDEX v1 FOR (n:Message) on n.ViewName
MATCH (message:Message)-[:REPLY_OF*0..]->(post:Post)-[:HAS_CREATOR]->(person) WHERE message.ViewName CONTAINS "V_IS2" RETURN ID(message) AS messageId, coalesce(message.imageFile,message.content) AS messageContent, message.creationDate AS messageCreationDate, ID(post) AS postId, ID(person) AS personId, person.firstName AS personFirstName, person.lastName AS personLastName ORDER BY messageCreationDate DESC, messageId ASC
MATCH p=(n:Person)-[r:KNOWS]-(friend) WHERE ID(n) = 6852 WITH p,r ORDER BY r.creationDate DESC, toInteger(ID(friend)) ASC WITH collect(id(r)) AS paths MERGE (v:View {ViewName :'V_IS3'}) SET v.PATHS = paths RETURN paths
MATCH (v:View) WHERE v.ViewName = "V_IS3" WITH v.PATHS AS allPaths UNWIND allPaths AS idR1 MATCH p=(n)-[r:KNOWS]-(friend) WHERE ID(r)=idR1 AND ID(n) = 6852 RETURN r.creationDate, ID(friend) AS personId, friend.firstName AS firstName, friend.lastName AS lastName
MATCH (m:Message) WHERE ID(m) = 0 SET m.ViewName = CASE WHEN m.ViewName IS NOT NULL THEN m.ViewName + ",V_IS4" ELSE ",V_IS4" END RETURN m
CREATE TEXT INDEX v1 FOR (n:Message) on n.ViewName
MATCH (n:Message) WHERE n.ViewName CONTAINS "V_IS4" RETURN n.creationDate as messageCreationDate, coalesce(n.content, n.imageFile) as messageContent
MATCH (m:Message)-[r1:HAS_CREATOR]->(p:Person) WHERE ID(m) = 7654 WITH DISTINCT(p) SET p.ViewName = CASE WHEN p.ViewName IS NOT NULL THEN p.ViewName + ",V_IS5" ELSE ",V_IS5" END RETURN p
CREATE TEXT INDEX v1 FOR (n:Person) on n.ViewName
MATCH (n) WHERE n.ViewName CONTAINS "V_IS5" RETURN n
MATCH p1=(m:Message)-[:REPLY_OF*0..]->(p:Post)<-[:CONTAINER_OF]-(f:Forum),p2 = (f)-[r1:HAS_MODERATOR]->(mod:Person) WHERE ID(m) = 5263 WITH collect(id(r1)) AS paths MERGE (v:View {ViewName :'V_IS6'}) SET v.PATHS = paths RETURN paths
MATCH (v:View) WHERE v.ViewName = "V_IS6" WITH v.PATHS AS allPaths UNWIND allPaths AS idR1 MATCH p=(f:Forum)-[r1:HAS_MODERATOR]->(mod:Person) WHERE id(r1)=idR1 RETURN ID(f) AS forumId,f.title AS forumTitle,ID(mod) AS moderatorId,mod.firstName AS moderatorFirstName,mod.lastName AS moderatorLastName
MATCH (m:Message)<-[r1:REPLY_OF]-(c:Comment)-[r2:HAS_CREATOR]->(p:Person) WHERE ID(m) = 139398 OPTIONAL MATCH p1=(m)-[r3:HAS_CREATOR]->(a:Person)-[r4:KNOWS]-(p)<-[r2]-(c)-[r1]->(m) WITH collect(id(r3) + '-' + id(r4)+ '-' + id(r2)+'-' + id(r1)) AS paths MERGE (v:View {ViewName:'V_IS7'}) SET v.PATHS = paths RETURN paths
MATCH (v:View) WHERE v.ViewName = "V_IS7" UNWIND v.PATHS AS path WITH SPLIT(path, '-') AS idPair, v WITH TOINTEGER(idPair[0]) AS idR1, TOINTEGER(idPair[1]) AS idR2, TOINTEGER(idPair[2]) AS idR3,TOINTEGER(idPair[3]) AS idR4 MATCH p=(m)-[r1:HAS_CREATOR]->(a:Person)-[r2:KNOWS]-(reply)<-[r3]-(c)-[r4]->(m) WHERE id(r1)=idR1 AND id(r2)=idR2 AND id(r3)=idR3 AND id(r4)=idR4 RETURN ID(reply) AS replyAuthorId,reply.firstName AS replyAuthorFirstName,reply.lastName AS replyAuthorLastName,CASE r2 WHEN null THEN false ELSE true END AS replyAuthorKnowsOriginalMessageAuthor ORDER BY replyAuthorId


